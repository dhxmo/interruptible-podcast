<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />

		<title>AIR</title>
		<link rel="icon" type="image/x-icon" href="web/favicon.ico" />
		<script src="web/dist/recorder.min.js" type="text/javascript"></script>
		<style>
			body {
				display: flex;
				justify-content: center;
				align-items: center;
				height: 100vh;
				background-color: #f4f4f4;
				font-family:
					-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
					"Helvetica Neue", Arial, sans-serif;
			}
			.container {
				background: white;
				height: window.innerHeight;
				padding: 20px;
				border-radius: 12px;
				box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
				text-align: center;
				display: flex;
				flex-direction: column;
			}
			.row {
				display: flex;
				flex: 1; /*each row takes equal height */
				justify-content: center;
				align-items: center;
				margin: 10px;
			}
			.row2 {
				height: 150px;
			}
			input,
			select {
				padding: 12px;
				font-size: 16px;
				border-radius: 8px;
				border: 1px solid #ddd;
				outline: none;
				transition: border-color 0.2s ease-in-out;
			}
			input:focus,
			select:focus {
				border-color: #007aff;
			}
			button {
				cursor: pointer;
				background-color: #f8f8f8;
				color: #333;
				border: 1px solid #ccc;
				padding: 12px 20px;
				font-size: 16px;
				border-radius: 8px;
				transition: all 0.2s ease-in-out;
				font-weight: 500;
			}
			button:hover {
				background-color: #e6e6e6;
			}
			button.interrupt {
				background-color: #f8f8f8;
				color: #333;
			}
			button.interrupt:hover {
				background-color: #e6e6e6;
			}

			#status {
				margin-top: 4rem;
				font-weight: bold;
			}

			#info {
				font-size: 7px;
			}
		</style>
	</head>
	<body>
		<div class="container">
			<div class="row row1">
				<input
					type="text"
					placeholder="What do you wanna talk about?"
					id="inputPrompt"
				/>
				<select id="selectTone">
					<option value="">Select a tone</option>
					<option value="news">News-like</option>
					<option value="historical">Historical</option>
					<option value="scientific">Scientific</option>
					<option value="explainer">Explainer</option>
					<option value="opinionated">Opinionated</option>
					<option value="dramatic">Dramatic</option>
					<option value="memoir">Memoir</option>
					<option value="meditative">Meditative</option>
					<option value="philosophical">Philosophical</option>
					<option value="tech&futurism">Tech & Futurism</option>
				</select>
			</div>
			<div class="row row2">
				<button id="btnSubmit">Submit</button>
			</div>
			<div class="row row3">
				<canvas id="waveCanvas"></canvas>
			</div>
			<div class="row row4">
				<button id="btnInterrupt">Interrupt</button>
			</div>
			<div class="row row5">
				<span id="info">long press to record</span>
			</div>
			<p id="status"></p>
		</div>

		<script>
			// network
			let socket = null;

			// audio
			let recorder;
			let isRecording = false;

			// playback
			let isProcessing = false;
			let audioQueue = [];
			let isPlaying = false;

			const textStatus = document.getElementById("status");
			const btnSubmit = document.getElementById("btnSubmit");
			const btnInterrupt = document.getElementById("btnInterrupt");

			// ------------ canvas animation
			const canvas = document.getElementById("waveCanvas");
			const ctx = canvas.getContext("2d");
			canvas.width = 450;
			canvas.height = 250;

			const centerX = canvas.width / 2;
			const centerY = canvas.height / 2;
			const circleRadius = 30;
			const waveRadius = circleRadius + 10;
			let angleOffset = 0;

			// Array to store wave objects
			const waves = [];
			const maxWaveRadius = 100; // Maximum radius before wave fades out completely
			const waveSpeed = 1; // Speed of wave expansion

			function createWave() {
				return {
					radius: circleRadius, // Start at the edge of the circle
					opacity: 1, // Start fully opaque
					angleOffset: Math.random() * 360, // Random starting angle for variety
				};
			}

			// Add initial waves (optional)
			for (let i = 0; i < 3; i++) {
				waves.push(createWave());
			}

			function draw() {
				ctx.clearRect(0, 0, canvas.width, canvas.height);

				// Draw static white center circle
				ctx.beginPath();
				ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
				ctx.fillStyle = "white";
				ctx.fill();
				ctx.closePath();

				if (!isProcessing && isPlaying) {
					// Add new wave periodically
					if (Math.random() < 0.1) {
						// 10% chance each frame
						waves.push(createWave());
					}

					// Draw and update waves
					for (let i = waves.length - 1; i >= 0; i--) {
						const wave = waves[i];
						wave.radius += waveSpeed; // Expand wave
						wave.opacity =
							1 - (wave.radius - circleRadius) / (maxWaveRadius - circleRadius); // Fade out

						if (wave.opacity <= 0) {
							waves.splice(i, 1); // Remove faded waves
							continue;
						}

						ctx.beginPath();
						for (let angle = 0; angle <= 360; angle += 5) {
							let rad = (angle + wave.angleOffset) * (Math.PI / 180);
							// Simulate audio wave with multiple sine components
							let waveHeight = (Math.sin(rad * 5) + Math.sin(rad * 3)) * 15;
							let x = centerX + (wave.radius + waveHeight) * Math.cos(rad);
							let y = centerY + (wave.radius + waveHeight) * Math.sin(rad);
							if (angle === 0) {
								ctx.moveTo(x, y);
							} else {
								ctx.lineTo(x, y);
							}
						}
						ctx.closePath();
						ctx.strokeStyle = `rgba(0, 0, 0, ${wave.opacity})`; // Black with fading opacity
						ctx.lineWidth = 2;
						ctx.stroke();

						wave.angleOffset += 2; // Animate the wave pattern
					}
				}

				requestAnimationFrame(draw);
			}

			// -- prompt related
			async function submitPrompt() {
				const inputPrompt = document.getElementById("inputPrompt").value;
				const selectTone = document.getElementById("selectTone").value;

				try {
					if (!inputPrompt || !selectTone) {
						alert("Error: Please fill what you wanna talk about");
						return;
					}
					const data = JSON.stringify({
						inputPrompt: inputPrompt,
						tone: selectTone,
					});

					if (socket.readyState === WebSocket.OPEN) {
						socket.send(data);
						// podcast research and script is being generated. TODO: show spinner
						isProcessing = true;
					}
				} catch (err) {
					textStatus.textContent =
						"Could not connect to WebSocket or access mic. Aborted.";
					console.error("Error submitting prompt", err.message);
				}
			}

			btnSubmit.addEventListener("click", submitPrompt);

			// --- playback related
			function startRecording() {
				if (!isRecording) {
					isRecording = true;
					recorder.start();
				}
			}

			async function stopRecording() {
				if (isRecording) {
					isRecording = false;

					try {
						await recorder.stop();

						// check socket conn and send msg out
						if (!socket || socket.readyState !== WebSocket.OPEN) {
							console.log("socket closed. reopening...");
							try {
								await initializeWebsocketAsync();
							} catch (err) {
								console.error("Error connecting websockets", err.message);
								return;
							}
						}
						const stopMessage = JSON.stringify({
							action: "stop_recording",
						});
						socket.send(stopMessage);
					} catch (err) {
						console.error("error stopping recording", err.message);
					}
				}
			}
			btnInterrupt.addEventListener("mousedown", startRecording);
			btnInterrupt.addEventListener("mouseup", stopRecording);

			// mobile
			btnInterrupt.addEventListener("touchstart", (e) => {
				e.preventDefault();
				startRecording;
			});
			btnInterrupt.addEventListener("touchend", (e) => {
				e.preventDefault();
				startRecording;
			});

			let audioContext = new (window.AudioContext || window.webkitAudioContext)(
				{
					sampleRate: 16000,
				}
			);

			async function initSourceNode() {
				try {
					// GUM and pipe to media source node
					const stream = await navigator.mediaDevices.getUserMedia({
						audio: true,
					});
					return audioContext.createMediaStreamSource(stream);
				} catch (err) {
					btnInterrupt.style.display = "None";
					let audioContext = new (window.AudioContext ||
						window.webkitAudioContext)({ sampleRate: 16000 });
					const stream = await navigator.mediaDevices.getUserMedia({
						audio: true,
					});
					return audioContext.createMediaStreamSource(stream);
				}
			}

			// https://github.com/mmig/opus-encdec?tab=readme-ov-file#general-config-options
			async function initializeRecorder() {
				// source node
				const sourceNode = await initSourceNode();

				// add config to recorder
				const config = {
					numberOfChannels: 1,
					encoderSampleRate: 16000,
					encoderFrameSize: 20,
					maxFramesPerPage: 40,
					encoderComplexity: 6,
					encoderApplication: 2048,
					originalSampleRate: 16000,
					streamPages: true,
					sourceNode: sourceNode,
				};

				recorder = new Recorder(config);

				// recorder onstart, ondataavailable, onstop
				recorder.onstart = () => {
					textStatus.textContent = "Recording...";
				};

				let audioChunks = [];

				recorder.ondataavailable = (buffer) => {
					audioChunks.push(buffer);
				};

				recorder.onstop = () => {
					// create blob from buffer chunks
					const blob = new Blob(audioChunks, {
						type: "audio/ogg; codecs=opus",
					});

					// clear chunk for next recording
					audioChunks = [];

					// send via socket to server
					if (socket && socket.readyState === WebSocket.OPEN) {
						console.log("ws sending", blob.size);
						socket.send(blob);
					} else {
						console.error("socket not open. error sending audio");
					}
				};
			}

			// [HACK] buffer should be queue
			function playAudioFromQ() {
				if (audioQueue.length === 0 || isPlaying) {
					return;
				}

				// if first time podcast generation, set false and disappear spinner
				if (isProcessing) isProcessing = false;

				isPlaying = true;
				const currentBlob = audioQueue.shift();
				const audio = new Audio(URL.createObjectURL(currentBlob));

				// -----------
				audio.onerror = (error) => {
					console.error("error in playback", error.mesage);
					isPlaying = false;
					playAudioFromQ();
				};

				// if blob done playing, play the next one
				audio.onended = () => {
					isPlaying = false;
					playAudioFromQ();
				};
				// -----------

				audio.play().catch((error) => {
					console.error("error in playback", error.mesage);
					isPlaying = false;
					playAudioFromQ();
				});
			}

			function qAudioPlayback(blob) {
				audioQueue.push(blob);
				playAudioFromQ();
			}

			// -- onload init
			async function initializeWebsocketAsync() {
				return new Promise((resolve, reject) => {
					// extract ws from url
					let currentURL = window.location;
					let wsProtocol = currentURL.protocol === "https" ? "wss:" : "ws:";
					let wsURL = `${wsProtocol}//${currentURL.host}/ws`;
					socket = new WebSocket(wsURL);

					// -----------
					socket.onopen = () => {
						console.log("websocket conected");
						textStatus.textContent = "Ready";
						btnInterrupt.disabled = false;
					};
					socket.onclose = (event) => {
						console.log("websocket closed", event.code, event.reason);
						textStatus.textContent = "Disconnected";
						btnInterrupt.disabled = true;
						reject(new Error("websocket closed"));
					};
					socket.onerror = (error) => {
						console.log("websocket error", error.message);
						textStatus.textContent = "Error";
						btnInterrupt.disabled = true;
						reject(error);
					};
					socket.onmessage = (event) => {
						if (event.data instanceof Blob) {
							// handle audio data from the server. queue and playback
							qAudioPlayback(event.data);
						} else {
							try {
								const message = JSON.parse(event.data);

								if (message.type === "error") {
									console.error("error in server", message.message);
									textStatus.textContent = "Server Error";
								}
							} catch (err) {
								console.error("error reading websocket data", err.message);
							}
						}
					};
					// -----------
				});
			}

			window.onload = async () => {
				draw();

				// initialize recorder
				await initializeRecorder();
				await recorder.initialize;

				try {
					await initializeWebsocketAsync();
					console.log("initialized");
				} catch (err) {
					console.error("error connecting websocket:", err.message);
				}
			};
		</script>
	</body>
</html>
